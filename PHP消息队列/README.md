# PHP 消息队列

###　消息队列概念
<pre>
    队列结构的中间件
    消息放入后，不需要立即处理
    由订阅者/消费者按顺序处理
    
    业务系统->(入队，同时返回业务成功的信息)->消息队列->(出队)->队列处理系统
</pre>

###　应用场景
<pre>
    冗余(业务流程复杂，操作时间很长的流程)
    
    解耦（入队系统与出队系统是不一样的，所以其中一个崩溃都不会影响另一个系统的操作）
    
    流量削峰 能够使服务器顶住瞬间的并发访问量，让服务器不容易崩溃
    
    异步通讯 从解耦的方面，就可以说明系统间的通讯是异步的
    
    扩展性 让别的系统订阅消息队列就可以拓展一个新的系统
    
    排序保证 单线程的单进单出，能够保证排序准确性
</pre>

### 队列介质
<pre>
    Mysql:可靠性高，容易实现，速度慢
    Redis:速度快，单条大消息包的效率低
    消息系统:专业性强，可靠，学习成本高
</pre>

### 消息处理触发机制
<pre>
    死循环方式读取:容易实现，故障时无法及时回复，同时占用较高，一般用于抢购秒杀等业务场景
    定时任务:压力均分，有处理上限.物流配货系统，每隔几分钟集中处理一次，这样压力不会太大，但是间隔和数量要调优，不要上一个定时任务没有结束，下一个任务又开始了，这样容易bug
    守护进程，类似于PHP-FPM和PHP-CG，需要shell基础
</pre>

###　解耦案例 队列处理订单系统和配送系统
<pre>
    订单系统并发业务量较大，容易出现高并发bug，但是订单时效性较高
    而配送系统则不需要跟着订单的生成而马上运转，这样会把并发的压力从订单处运转到配送处，这样，需要对这两个系统进行解耦
    通过中间的队列表来进行沟通
</pre>

### Redis 秒杀代码级设计
<pre>
    秒杀程序把请求写入Redis，(仅需保存UserID,和写入的TimeStamp)
    检查Redis已经存放数据的长度，超出上限直接丢弃
    死循环处理存入Redis的数据库并入库
</pre>