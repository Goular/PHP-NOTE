#第十五天笔记
#抽象类
<pre>
是一个不能实例化的类；

定义形式：
abstract  class  类名{}

为什么需要抽象类：
它是为了技术管理而设计！
</pre>

#抽象方法
<pre>
是一个只有方法头，没有方法体的方法定义形式；

定义形式：
abstract  function  方法名( 形参1，形参2，.... )；	//注意，这里必须有分号；

为什么需要抽象方法：
它也是为了技术管理而设计：要求下级类需要去实现这个方法的“具体做法”；
</pre>

##抽象类和抽象方法细节
<pre>
1，一个抽象方法，必须在抽象类中；
2，反过来，抽象类中可以没有抽象方法——虽然不常见；
3，可见：抽象方法是为了规定下级类中“必须”要具体去完整某个工作（任务）；
4，下级类中继承了上级类的抽象方法，则要么去“实现该方法的具体内容”，要么自己也作为抽象类（即其继承的抽象方法仍然是抽象的）；
5，子类实现父类的抽象方法的时候，其形参也应该跟父类保持一致，其访问权限也不能更小；
——其原因其实这是“重写现象”，自然应该遵循重写的要求；
</pre>

#重载技术overloading
###重载的基本概念
<pre>
重载在“通常面向对象语言”中的含义：
是指，在一个类（对象）中，有多个名字相同但形参不同的方法的现象；
类似这样：
class   C{
function  f1(){。。。}
function  f1($p1){。。。}
function  f1($p1,  $p2  ){。。。}
}
$c1 = new C();
$c1->f1();
$c1->f1(2);
$c1->f1(3,4);

重载在“php语言”中的含义：
是指，当对一个对象或类使用其未定义的属性或方法的时候，其中的一些“处理机制”；
比如：
class  A{
public  $p1 = 1;
}
$a1 = new A();
echo   $a1->p1;		//1；
echo   $a1->p2;		//出错，未定义的属性！
则：php中的重载技术，就是来应对上述“出错”的情况，使代码不出错，而且还能“优雅处理”；
</pre>

###属性重载
<pre>
就是对一个对象的不存在的属性进行使用的时候，这个类中预先设定好的应对办法（处理机制）；

属性，本质，就是变量，其只有4个操作：
取值：
当对一个对象的不存在的属性进行“取值”的时候，就会自动调用内部方法：__GET()
赋值：
当对一个对象的不存在的属性进行“赋值”的时候，就会自动调用内部方法：__SET()
判断（isset）：
当对一个对象的不存在的属性进行isset()判断的时候，就会自动调用内部方法：__isset()
销毁（unset）：
当对一个对象的不存在的属性进行unset()销毁的时候，就会自动调用内部方法：__unset()

以上，4个方法，被称为“魔术方法”；
</pre>

#####__GET($属性名)
<pre>
在对一个对象的不存储的属性进行“取值”的时候，会自动调用的方法；
我们其实是可以使用该方法来对这种“意外”情况进行某种特别的处理。
其中，该方法可以带一个形参，表示这个要对之取值的不存在的属性名（字符串）；
</pre>

#####__SET($属性名，值)
<pre>
当对一个对象的不存在的属性进行“赋值”的时候，就会自动调用这个内部的魔术方法；
它有2个形参，分别代表要对不存在的属性进行赋值的时候的“属性名”和“属性值”；

这个方法，结合__GET方法，往往可以使我们定义的类，就有一种“可方便扩展属性”的特性。
即：类（或对象）的属性，可以更为方便自由，
</pre>

#####__ISSET($属性名)
<pre>
当对一个对象的不存在的属性进行isset()判断的时候，就会自动调用内部方法：__isset()；
用法：
$v1 = isset($对象 -> 不存在的属性);	//	此时就会调用这个对象的所属类中的魔术方法：__isset()
</pre>

#####__UNSET($属性名)
<pre>
当对一个对象的不存在的属性进行unset()销毁操作的时候，就会自动调用内部方法：__unset()
</pre>

###方法重载
<pre>
当对一个对象的不存在的实例方法进行“调用”的时候，会自动调用类中的__call()这个魔术方法；

当对一个类的不存在的静态方法进行“调用”的时候，会自动调用类中的__callstatic()这个静态魔术方法；

例子源码:
利用__call（$name,$array）方法实现普遍面向对象的重载技术
</pre>

#接口(interface)技术
<pre>
记住，接口的属性只能使用常量

接口就是这样一个“天然不实在”的家伙：
接口，就是规定，里面只能放“抽象方法”和“常量”的一种类似类的语法结构；
——可见，接口就是“比抽象类更抽象的”一种语法结构。

接口（interface)定义形式：
interface  接口名{
常量1；
常量2；
.....
抽象方法1；
抽象方法2；
.....
}
说明：
1，可见，接口中，只有常量（接口常量）和抽象方法两种成员；
2，接口常量的使用形式为： 接口名称：：常量名称；
3，接口中的抽象方法，不要使用abstract修饰，也不需要使用访问控制修饰符，因为其天然就是public

为什么需要接口？
面向对象编程思想是对“现实世界”的描述（模拟）！
现实世界往往都都是多继承的；
但：
出于降低类跟类之间关系的复杂度的考虑，就将语言设计为单继承的；
但这样，就无法表达出现实世界的多继承特性；
则：
接口就是对没有多继承的类之间关系的一个补充；

因为：接口可以实现“多继承”——但此时不称为继承而已，而是称为“实现”；
即：
接口1  -->> 类1；
就称为：类1实现了接口1；
其本质，其实就是类1中，有了接口1中“特征信息”；

使用形式：
形式为：
class  类名  implements  接口名1， 接口名2， ....{	
//类的定义。
}
这里，叫做，类实现了接口。


需要值得注意的是，接口之间也是能否进行继承的
其中，接口跟接口之间，也可以继承，跟类之间的继承：
interface  接口1  extends  接口2{
//接口的成员定义；。。。。
}
</pre>

###实例
<pre>
进一步完善mysqldb工具类：
完善分2个方面：
1，现有已经完成的功能，做优化处理；
2，添加更多的功能，要求继续实现如下功能：
2.1：用该类的对象可以执行任意的增删改语句，并返回布尔值；
2.2：用该类的对象可以执行返回一行数据的“查询语句”：结果是一个一维数组，类似这样：
array( ‘id’=>3,  ‘name’=>’张三’,  ‘age’ => 18,  ‘edu’=>’大学’ );
2.3：用该类的对象可以执行返回多行数据的“查询语句”：结果是一个二维数组，类似这样：
array（
0=>array( ‘id’=>3,  ‘name’=>’张三’,  ‘age’ => 18,  ‘edu’=>’大学’ )，
1=>array( ‘id’=>4,  ‘name’=>’张四’,  ‘age’ => 14,  ‘edu’=>’中学’ )，
2=>array( ‘id’=>7,  ‘name’=>’张七’,  ‘age’ => 17,  ‘edu’=>’小学’ )
）
2.4：用该类的对象可以执行返回一个数据的“查询语句”：结果是一个数据值，其sql语句常常类似这样：  select  name  from  Users  where id = 1;  或： select  count(*) as c  from  表名；

一定要看代码：《MySQLDB.class.php》及其应用：《9mysqldb_yingyong.php》

</pre>
