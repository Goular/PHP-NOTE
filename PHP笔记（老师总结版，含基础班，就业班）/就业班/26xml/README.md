#XML
###XML作用
<pre>
两个大的方面：
	保存
	交换（传输）

交换数据的层面:
Ajax：Asynchronous JavaScript and xml，异步的js和xml，现在都喜欢json
Web service：web 服务 （xml最擅长的地方）
Svg，可伸缩的矢量图形
</pre>

###XML格式
<pre>
整个xml，是树形结构，有且仅有一个根节点（非常重要）。
在这个树形结构中，有三种节点，元素节点+属性节点+文本节点
</pre>

###XML语法
<pre>
所有的标签和属性都是小写的。是指标签和属性本身。
所有的标签都需要关闭，双标签 <div></div> 单标签 <br /> <img />。
所有的属性都应该有值，如果属性没有指，则使用自身来表示。
所有的属性都应该使用引号括起来，单双均可。
标签是可以嵌套的，但是不能相互交叉（骑跨）<div><h2></h2></div>  √ <div><h2></div></h2> ×


</pre>

###xml的语法总则
<pre>
它必须以 XML 声明开头
它必须拥有唯一的根元素
开始标签必须与结束标签相匹配
元素对大小写敏感，严格区分大小写
所有的元素都必须关闭，注意单标签
所有的元素都必须正确地嵌套
必须对特殊字符使用实体 

version：版本号，目前推荐是1.0
encoding：编码，字符集，建议使用utf-8
standalone：是否呼叫外部的dtd文件，默认是no。

唯一，需要注意的是字符集，如果有乱码，肯定字符集设置不对的。保证你声明的字符集和文件本身保存的字符集的一致。
</pre>


###命名规则
<pre>
由于我们的xml中，所有的标签都需要自己来定义
名称可以含字母、数字以及其他的字符 
名称不能以数字或者标点符号开始 
名称不能以字符 “xml”（或者 XML、Xml）开始 
名称不能包含空格 
可使用任何名称，没有保留的字词。

建议，使用php的命名方式，尽量使用数字、zimu、下划线的组合。
Xml支持中文。（但一般不用）

☞ 注意事项
避免 "-" 字符。如："first-name"，一些软件会认为你需要提取第一个单词。
避免 "." 字符。如："first.name"，一些软件会认为 "name" 是对象 "first" 的属性。
避免 ":" 字符。冒号会被转换为命名空间来使用。

在我们的xml中，主要是三种节点：元素节点，属性节点，文本节点
</pre>

###定义属性
<pre>
属性，它是依赖于元素而存在的，寄生虫。不能独立的存在。
在元素的开始标记中来定义的，通常是用来表附加信息的。

<file type="gif">computer.gif</file>

☞ 注意事项
属性值必须被引号包围，不过单引号和双引号均可使用。
一个元素可以有多个属性
元素中的属性是不允许重复的
标签属性所代表的信息也可以被改成用子元素的形式来描述

因使用属性而引起的一些问题：
属性无法包含多重的值（元素可以） 
属性无法描述树结构（元素可以） 
属性不易扩展（为未来的变化） 
属性难以阅读和维护 
请尽量使用元素来描述数据。而仅仅使用属性来提供与数据无关的信息。

经验：设计表的时候，有一个主键，主键是和具体的业务逻辑是无关的。
</pre>

###实体引用
<pre>
&lt;
&gt;
&amp;
&apos;
&quot;

实际上，在5个当中，只有 < 和 &，会引起错误。

为了解决实体引用引起bug的麻烦，所以我们会使用CDATA进行包裹，这样编译器就不会翻译内部的内容

< ![CDATA[
实体内容
]]>

注意，CDATA节的写法：不要写错，不要脱节，不要嵌套。
</pre>

###注释
<pre>
和HTML的一模一样
<!-- 注释内容 -->
</pre>

###DTD验证
<pre>
双方应该遵循一个规则。谁来指定规则，如何检验是否遵循规则。

Xml其实是需要通过验证的。
通常有两种方式：
DTD：Document Type Definition，文档类型定义，目前使用最多的一种
Schema：结构，XSD,Xml Schema Definition，文档结构定义，未来的趋势，功能强大。
</pre>

###DTD作用
<pre>
通过DTD可以干什么？
通过 DTD，独立的团体可一致地使用某个标准的 DTD 来交换数据。
而您的应用程序也可使用某个标准的 DTD 来验证从外部接收到的数据。
您还可以使用 DTD 来验证您自身的数据。

注意事项
DTD描述了XML文档有哪些节点、节点之间的关系以及节点的值等。（学习重点）
DTD验证的不是语法，而是验证XML文档中应该有哪些节点，节点之间的关系是什么，元素的值、属性的值应该由什么内容组成。
XML没有DTD，可以正常工作，但不能很好的工作。
合法的 XML 文档是“形式良好”的 XML 文档，且遵守文档类型定义 (DTD) 的语法规则。


Xml文档是一种树形结构，包括三种节点：元素节点，属性节点，文本节点
我们要定义这个DTD，也需要从这方面来考虑。
</pre>

###元素定义
<pre>
格式：<!ELEMENT 元素名 (元素内容描述)>
注意，中间有空格，
重点关注的是元素内容描述。

首先，我们分析一下元素的表现形式：
仅包含元素的元素
仅包含文本的元素
包含文本和元素的混合内容：105个男人和<strong>3个女人</strong>的故事
空元素
任意元素
</pre>

###包含元素的元素
<pre>
相对简单，通常有两种结构：
顺序结构，直接使用 逗号 分隔开
	意味着，每个元素都要出现，并且只能出现一次，还要按照顺序依次出现。
选择结构，使用 | 分割
	非a即b


如果需要某个元素出现多次，如何处理？
使用数量词即可，有三种数量词：
*: 任意个，包括0
+: 至少一个，至多不限
?: 0或1个
</pre>

###仅包含文本的元素
<pre>
这种比较简单，最简单。

也就是说，在元素中，包含的是纯文本。不要再嵌套其他任何标签。
直接使用 (#PCDATA) 可解析的字符数据，说白了，就是普通字符串。
</pre>

###包含文本和元素的元素
<pre>
第一种和第三种，都是包含仅文本的 body (#PCDATA)
第二种是包含元素，body (strong)

将它们结合到一起

body (#PCDATA)  body (strong)  body (#PCDATA)

结合前面所学的 选择结构 + 数量词 
body (#PCDATA|strong)*
</pre>

######[注意]：在DTD文件内部定义混合内容模型，必须要使用选择组合，#PCDATA关键字必须出现在子元素列表的第一个位置，且必须要使用*。

###空元素
<pre>
直接使用empty
<!ELEMENT br EMPTY>
使用方式1：
< br/>
使用方式2：
< br>< /br>
</pre>

###任意元素
<pre>
可以是任意的内容，使用ANY来声明
声明了这个any之后，就可以在any元素中包含任何内容。
所以，实际上我们很少会使用any。
</pre>

###符号统计
<pre>
EMPTY
ANY
#PCDATA
,
|
()
*
?
+
</pre>

###属性定义
<pre>
属性很特殊，是依赖于元素而存在的，声明属性一定或和元素挂钩的。
所以，声明一个属性，我们需要得知如下几个要素：
属于哪个元素
属性名称
属性的类型
属性的取值方式

定义的属性格式：<!ATTLIST 元素名 属性名称 属性的类型 取值方式>

属性的类型在枚举的状态下是不用双引号将值包括起来的
 <!ATTLIST user gender (男|女)  '男'>

b.关于取值类型，必须要设置
如果没有固定值、又没有默认值，而且也不是必须的，那么此时一定要声明为#IMPLIED。

细节，
a.ATTLIST，可以一次性定义多个属性，
b.可以省略部分的属性
</pre>


###实体定义
<pre>
文本节点，本身是无需定义的。
书写字符串的时候，有时候会重复的使用某个的内容，此时为了 方便，可以将其定义为实体。类似在编程中的变量的含义。

除了XML预定义的5个实体之外，我们还可以自己来定义实体。

DTD中，通常有两种实体：
一般实体，在DTD中来定义的，然后在xml文档中来引用的
参数实体，在DTD中来定义的，但是他是在DTD中引用的。
</pre>


###实体定义
<pre>
文本节点，本身是无需定义的。
书写字符串的时候，有时候会重复的使用某个的内容，此时为了 方便，可以将其定义为实体。类似在编程中的变量的含义。

除了XML预定义的5个实体之外，我们还可以自己来定义实体。

DTD中，通常有两种实体：
一般实体，在DTD中来定义的，然后在xml文档中来引用的
参数实体，在DTD中来定义的，但是他是在DTD中引用的。
</pre>


###一般实体
<pre>
定义格式：< !ENTITY 实体名称 值>
引用：&实体名称;

既可以在内部定义中使用，也可以在外部实体中定义然后使用。

单独的定义一个外部DTD，然后在xml文档中引入外部DTD，也是可以使用的。
然后在xml文档中，引入dtd，并引用实体

外部引用的格式
< !DOCTYPE note SYSTEM 'note.dtd'>
</pre>

###参数实体
<pre>
只能是在外部DTD中定义，并且只能在DTD中引用。
意味着：
A.必须以外部的方式来引用DTD
B.参数实体，不能直接在xml中引用，只能在DTD中引用

定义格式：< !ENTITY % 实体名称 值>
引用格式：%实体名称;

对应的在xml文档中来引用一般实体，如果引用参数实体，是不能解析的。

此处，还需要注意一点，不要用浏览器来看它们的效果，
原因在于对于外部DTD，我们的浏览器它是不会去加载的。

使用方法，在DTD的定义中，使用参数实体 %参数实体名
</pre>

###DOM方式操作XML
<pre>
PHP操作xml的方式非常之多，12种左右。

DOM方式：所有语言都支持的方式，并且是一样API，稍微难一点
SimpleXML方式：php提供一种简单的方式，非常简单。
</pre>

###DOM操作XML步骤
<pre>
 注意事项
1.php利用DOM系列对象，完成上述操作。
2.在第一步中，我们只需提供哪个文档需要转换即可，其它的交给php来完成。
3.在第三步中，只需调用php的方法即可。
</pre>

###DOM方法处理的四个核心类
<pre>
1.DOMDocument
2.DOMElement
3.DOMNode
4.DOMNodelist

注意，DOMNodeList 和DOMNode的关系

这里，就有一个抽象类，就是DOMNode。
在使用的过程中，并不会直接使用DOMNode对象，我们用的是DOMElement。

DOMNode其实指的节点，节点有分成三种：元素（DOMElement）、属性、文本。
我们一般只会使用DOMElement，不用属性和文本元素。
</pre>

###DOM完成CRUD(获取根节点方法：$dom->documentElement)
<pre>
(1).查询
(2).增加
	注意createElement方法的定义，如下：
		有两个参数，
		如果我们创建的是仅包含元素的元素，就只需要第一个参数，
		如果我们创建的是仅包含文本的元素，需要两个参数。
		
	还有使用的方法是setAttribute(),$dom->documentElement->append()
	
(3).更新
	使用了DOMNodelist后遍历修改即可
	注意，对于DOMNodeList对象，它可以直接遍历得到DOMElment呢？
	实际上，它实现了遍历接口。

(4).删除---有陷阱
	[需求1]：删除第二本书的year元素
		使用removeChild方法，是通过父节点来进行调用的。
	对于单个删除，很简单。

	[需求2]：删除所有书籍的year元素
		结果很奇葩，处在奇数位置的year元素删除掉了，但是偶数位置的那个却没有删除。Why？


	[注意]，在删除节点的同时，不要对他进行foreach操作

	在删除节点的同时，进行了foreach操作，导致结果出现紊乱。

	解决办法：只需要将二者分开即可。先遍历，找到所有的节点，用到保存起来，然后再对他进行删除。

	//第一步，保存所有year的节点
	$temp = array();
		foreach ($years as $year) {
   		$temp[] = $year;
	}

	//遍历year节点并删除内容
	foreach ($temp as $tem) {
    	$tem->parentNode->removeChild($tem);
	}
</pre>


###(5).验证
<pre>
在默认情况下，对于外部的DTD而言，我们的xml文档不会加载引用的外部DTD。

需要让xml文档强制加载外部DTD。换句话说，需要使用外部DTD文件来验证我们的xml文档。

需要使用PHP的方法进行校验
有两种方法来验证：
validateOnParse属性
Validate()方法

其中validateOnParse属性的默认值是false，所有无法加载外部DTD。

如果使用属性，一定要写在load之前。

//在载入之前进行强制加载外部的DTD
$dom->validateOnParse = true;//设置强制设置加载外部DTD
//设置好校验属性后进行载入xml
$dom->load('note.xml');

再次强调，我们的xml不是用来显示的， 是用来传输或交换数据的。所以只要能获取到该数据就行了。

还可以使用validate()方法进行验证

考虑一个问题：能否使用getElementById呢？
可以，但是需要在DTD中进行定义，并且要强制加载进来才行。

在执行getElementById之前，必须开启dtd配置，不然会报警告
$dom->validateOnParse = true;

在dtd中定义id属性
</pre>

#XML应用之在线词典
###1.词条录入
<pre>
	首先，编写一个录入的界面
	
	接下来，编写dict_add.php，完成词条的录入

	添加词条效果如下：
</pre>

###2.词条查询
<pre>
对于单词量比较少的情况，还可以勉强应付，如果单词多了，会怎么办？

使用dic.xml来测试。查询最后一个单词，结果如下：

apache有30秒的访问时间，时间已过，访问结束，报错输出


这说明我们的代码效率不高。

原因：我们使用了顺序查找，对于n条，平均需要查找 n*(n+1)/2
解决办法：一种办法是先进的查找算法，二分查找。Log2N 

Xml提供了一个xpath，可以快速的查询。
</pre>

###XPATH
<pre>
XPath，xml路径。
类似于电脑磁盘中的路径，/
使用xpath，可以快速的定位到某个节点。

提供很多的用法，包括还有很多函数。
表达式          描述
/              从根节点选取
//			   不考虑位置选取指定的节点
.			   选取当前节点
..			   选取当前节点为父节点
@              选取属性
</pre>

###谓语
<pre>
谓语用来查找某个特定的节点或者包含某个指定的值的节点。
谓语被嵌在方括号中。

在使用数量词，或者last、position函数的时候，一定要注意，是针对同一个节点下面的元素。它们应该有共同的父节点。

$query = "//title[last()]";//其实这个获取的是第一个title,因为同一层次下title确实没有其他的title，所以返回的是第一个title，第一个即最后一个,就是说他们必须是同一个父亲才有上一个下一个的说法

</pre>

###其他用法
<pre>
或的关系
//book/title | //book/price				选取 book 元素的所有 title 和 price 元素。
//title | //price						选取文档中的所有 title 和 price 元素。
/bookstore/book/title | //price			选取属于 bookstore 元素的 book 元素的所有 title 元素，以及文档中所有的 price 元素。

通配符
*    匹配任何元素
@*   匹配任何属性
node() 匹配任何类型节点

Xml比作数据库中的表。
Xpath就好比是表中的索引，加快查询速度。


使用xpath的速度比getElementByTagNames的速度快多了

</pre>

###SimpleXML
<pre>
它是PHP专门提供的一种操作xml的简单方式，特点就是只能在php中使用，真的是简单。
基本上，就只有一个对象。SimpleXMLElement。

1.操作步骤：三步走

	1.载入xml文档
	2.进行具体的处理
	3.将结果保存回来。


得到SimpleXMLElement有两种方式：
	直接使用构造方法，传递的xml的内容，不是文件名

	使用普通函数，传递的文件名，simplexml_load_file 


</pre>

###增加
<pre>
	addChild()
	addAttribute()
</pre>

###查询
<pre>
[需求]：对于bookstore.xml，将其以表格的形式显示到页面中

得到的SimpleXMLElement对象中，只有两种东西，一个是对象SimpleXMLElement，一个是数组。只需要使用数组的遍历+对象属性的访问就可以。
</pre>

###修改
<pre>
</pre>

###删除
<pre>
如何删除呢？
	删除一个变量：unset
	删除一个数组中的元素：unset
	删除对象中的一个属性：unset
</pre>

###XML应用之RSS
<pre>
什么是rss
	RSS：Really Simple Syndication，简易信息聚合。

新闻和博客网站应用比较多。

	我在自己网站中，可以提供一个订阅的链接。

	在显示新闻或博客内容的同时，制作一个订阅源。其实就是生成一个xml文档。

	这个xml必须有固定的格式和规范。

</pre>

###2.制作自己的rss订阅源
<pre>
内容通常是从数据库读取的。

写一个php文件，从数据库中读取数据，并生成一个xml文档（固定格式）。

生成xml文档有几种方式：
	DOM方式
	SimpleXML方式
	拼凑字符串

因为我们是生成xml，并不是在已有xml的基础上进行操作，所以用拼凑字符串最简单。



第一步，取数据
第二步，生成xml
第三步，我们在blog.html页面中，提供一个超链接指向该文件
访问blog.html，如下
[注意点]：请使用firefox浏览器来查看效果，它默认安装了rss订阅器。
</pre>

###十.XML应用之Web Service
##本质就是通过网络调用其他网站的资源。
<pre>
1.什么是web service？
拆分开来
Service：服务，在电脑安装一个软件（程序），可以为我们提供某些功能，就可以称之为服务。本地服务比较多。
Web：和本地相对应，在互联网上的。

Web service，通过互联网来提供某种服务。

本质就是通过网络调用其他网站的资源。

Web service vs 本地服务

本地服务的缺陷：
本地资源不足。很多数据和资料，本地得不到，只有向其他网站要。
成本因素。本地提供服务，往往是不经济的，使用专业网站的服务更便宜。
可移植性差。

Web Service的优势：
平台无关。不管你使用什么平台，都可以使用Web service。
编程语言无关。只要遵守相关协议，就可以使用任意编程语言实现Web service。
对于Web service提供者来说，部署、升级和维护Web service都非常简单
对于Web service使用者来说，可以轻易实现多种数据、多种服务的聚合（mashup），因此能够做出一些以前根本无法想像的事情。


服务器端提供服务器
客户端使用服务

重点关注两个东西：
SOAP
WSDL

如果只是使用别人的服务，只需要简单了解即可。（基本上就是这一种）
如果需要给别人提供服务，需要深入理解。
</pre>

###SOAP(使用前必须打开PHP的SOAP拓展)
<pre>
SOAP：Simple Object Access Protocol，简单对象访问协议。
SOAP = XML + HTTP

如何操作呢？
Php提供了web service的扩展。
</pre>

###WSDL
<pre>
Web Service Description Language : web 服务描述语言。
简而言之，就是xml文档。
</pre>

###使用web service实现航班查询
<pre>
(1).服务在哪儿
http://www.webxml.com.cn/zh_cn/web_services.aspx

(2).获取所有的城市列表
使用准备好的airline.html，改名为airline.php，

查看soapclient 的构造方法，定义定义：
只需要传递一个wsdl文件，其实就是人家已经提供好的那个xml文档。

其实，通过调用对象的属性，就可以获取，得到的结果是一个字符串，字符串的内容是xml文档。
使用simplexml来完成查询即可。

(3).查询航班

一些细节的地方，大家自行处理一下。

类似这样的web service还有很多。

微信开发。
</pre>