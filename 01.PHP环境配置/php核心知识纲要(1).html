<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>PHP核心知识纲要</title>
<script src="jquery-1.7.1.js"></script>
<script>
	$(function(){
		$("ul").hide();
		$("body>ul").show();

		$("li").each(function(){
			if($(this)[0].childNodes.length > 1 && $("ul",this).size() > 0)
			{
				$($(this)[0].childNodes[0]).wrap("<a href='#'></a>");

			}
		});
		$("li > a").click(function(){
			$(this).next().toggle();
			$(this).css({"text-decoration":"underline"});
			return false;
		});
		$("ul:first").dblclick(function(){
			$("ul").show();
		});
		
		//$("li>ul").toggle();
		//$("li>ul:first").toggle();

	});
</script>
<style type="text/css">
<!--
body,td,th {
	font-family: 微软雅黑;
}
-->
</style></head>

<body>
<ul>
  <li>php介绍 
    <ul>
      <li>缩写：Personal Home Page  ==&gt;&gt;PHP：HypeText  Preprocessor </li>
      <li>历史
        <ul>
          <li>1995PHP/FI，Rasmus Lorderf，Personal Home Page </li>
          <li>1997PHP/FI2.0，1998PHP3，2000PHP4，2005PHP5 </li>
        </ul>
      </li>
      <li>应用范围：
        <ul>
          <li>web服务器端脚本：主要作用</li>
          <li>命令行脚本
            <ul>
              <li>运行php文件：php.exe -f &quot;php文件路径&quot;</li>
              <li>运行php代码：php.exe -r &quot;php脚本代码&quot;</li>
            </ul>
          </li>
          <li>应用程序图形界面 </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>php运行环境
    <ul>
      <li>BS软件模式
        <ul>
          <li>浏览器软件若干 </li>
          <li>web服务器软件若干 </li>
          <li>后台程序语言若干 </li>
          <li>web运行流程：
            <ul>
              <li>浏览器输入地址，回车（发送请求） </li>
              <li>根据规则找到对应web服务器。规则如下：
                <ul>
                  <li>首先在本机hosts文件中找对应IP </li>
                  <li>如果hosts中没有找到，则到互联网上找对应IP </li>
                  <li>如果还是没有找到，则终止请求，返回“找不到服务器”提示 </li>
                </ul>
              </li>
              <li>web服务器取得对应文件 </li>
              <li>如有需要，对该文件进行一定的处理（比如php代码执行） </li>
              <li>将文件（或执行结果文件）返回给浏览器（返回应答） </li>
              <li>浏览器接收到文件 </li>
              <li>浏览器处理文件（显示/执行） </li>
            </ul>
          </li>
        </ul>
      </li>
      <li>web服务器运行模式
        <ul>
          <li>安装apache软件
            <ul>
              <li>测试apache </li>
            </ul>
          </li>
          <li>将php配置为apache模块：loadModule php5_module &quot;php5apache2_2.dll路径&quot;</li>
          <li>告知apache何时调用php模块
            <ul>
              <li>方式1：FilesMatch〉setHandler &quot;application/x-httpd-php&quot;</li>
              <li>方式2：addType application/x-httpd-php .php .php3</li>
              <li>测试php运行: </li>
            </ul>
          </li>
        </ul>
      </li>
      <li>配置php
        <ul>
          <li>使用phpinfo()测试。</li>
          <li>确定php的配置文件
            <ul>
              <li>PHPIniDir 设定php.in文件位置 </li>
            </ul>
          </li>
          <li>修改php配置
            <ul>
              <li>设置时区：timezone=PRC </li>
              <li>设置扩展库目录：extension_dir </li>
              <li>打开扩展库：mysql, mysqli </li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>安装mysql数据库
    <ul>
      <li>安装过程： </li>
      <li>相关配置过程：
        <ul>
          <li>设置环境变量以方便登录 </li>
          <li>对php.ini，可以打开对应扩展mysql </li>
        </ul>
      </li>
      <li>操作mysql数据库的基本流程
        <ul>
          <li>客户端连接mysql服务器 </li>
          <li>客户端发送命令（操作语句） </li>
          <li>服务器执行语句 </li>
          <li>服务器返回执行结果 </li>
          <li>客户端展示执行结果 </li>
          <li>断开连接（退出登录） </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>虚拟主机基本配置
    <ul>
      <li>端口监听设置 </li>
      <li>主机配置的关键项
        <ul>
          <li>主机名： </li>
          <li>主机目录： </li>
        </ul>
      </li>
      <li>目录的访问设置
        <ul>
          <li>Options</li>
          <li>Order</li>
          <li>Allow和Deny</li>
          <li>AllowOverride</li>
          <li>.htaccess文件 </li>
        </ul>
      </li>
      <li>其他相关设置
        <ul>
          <li>默认页设置DirectoryIndex </li>
          <li>主机别名设置ServerAlias </li>
          <li>目录别名设置Alias </li>
        </ul>
      </li>
      <li>多域名虚拟主机配置：
        <ul>
          <li>打开主配置文件中的httpd-vhosts.conf开关 </li>
          <li>编辑多域名配置文件httpd-vhosts.conf</li>
          <li>设定要进行多域名配置的IP及端口：NameVirtualHost *:80</li>
          <li>一个一个主机进行配置：
            <ul>
              <li>设定主机域名：ServerName</li>
              <li>设定主机目录：DocumentRoot</li>
              <li>设定目录访问：Directory权限设定 </li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>PHP运行基本环境配置与设定
    <ul>
      <li>确定配置文件所在位置：用phpinfo.php查看 </li>
      <li>修改php的时区设定 </li>
      <li>设定php的标记形式：
        <ul>
          <li>典型（标准）标记形式 </li>
          <li>脚本形式&lt;script language=&quot;php&quot;&gt;</li>
          <li>短标记形式：short_open_tag </li>
          <li>结束标记有时可以省略</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>php基本语法形式：
    <ul>
      <li>区分大小写
        <ul>
          <li>是指变量名区分大小写</li>
          <li>但函数名不区分</li>
          <li>而系统中使用的关键字也不区分大小写，比如if， else， for</li>
        </ul>
      </li>
      <li>一条语句使用一个分号结束
        <ul>
          <li>最后一个分号可省略 </li>
          <li>php结束标记省略则不能省略最后一个分号 </li>
        </ul>
      </li>
      <li>php注释形式
        <ul>
          <li>单行注释
            <ul>
              <li>//常规风格（推荐） </li>
              <li>#配置文件风格 </li>
            </ul>
          </li>
          <li>多行注释
            <ul>
              <li>多行注释技巧1：/*.... //*/ </li>
              <li>多行注释技巧2：if语句 </li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>变量：
    <ul>
      <li>含义：包含名称和值一个标识符
        <ul>
          <li>名称和值的关系可以称为“引用” （指向）</li>
          <li>使用一个变量名其实是指使用该变量所“引用”（指向）的值</li>
        </ul>
      </li>
      <li>使用形式：变量必须以$开头，后面紧跟变量名 </li>
      <li>定义形式：直接给一个变量赋值，如果是第一次，就算是定义了——没有单纯的定义变量而不赋值的语句。</li>
      <li>变量基本操作：
        <ul>
          <li>赋值： </li>
          <li>取值： </li>
          <li>判断isset()： 就是判断一个变量是否“有效”，不存在或值为null都是无效的，其他有效。</li>
          <li>删除unset()：就是断开变量名跟数据之间的“引用关系” </li>
        </ul>
      </li>
      <li>变量命名基本规则
        <ul>
          <li>以字母或下划线开头</li>
          <li>后跟任意数量（含０个）的字母，数字和下划线 </li>
        </ul>
      </li>
      <li>变量命名推荐规则：
        <ul>
          <li>骆驼命名法： </li>
          <li>帕斯卡命名法： </li>
          <li>下划线间隔法： </li>
        </ul>
      </li>
      <li>变量间的传值方式：
        <ul>
          <li>赋值传值（值传递）：在php中，变量之间默认都是“值传递”，语法形式为：$v1 = $v2； 即将一个变量的“数据内容”复制一份再赋值给另一个变量。</li>
          <li>引用传值（引用传递）：可以使用“&amp;”运算符来强制引用传值，语法形式为：$v1 = &amp;$v2;
            <ul>
              <li>例：$v1 = 10; $v2 = &amp;$v1;</li>
              <li>$v2 = 20;</li>
              <li>则：echo $v1;//结果是20，这就是引用。</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>可变变量： 变量的名字本身又是一个变量，则此时称其为可变变量，形式类似这样：$$变量名;
        <ul>
          <li>例：$a = 'b'; $b = 10; 则 echo $$a; 输出结果是10，此时“$$a”就是可变变量；</li>
        </ul>
      </li>
      <li>预定义变量（超全局变量/数组）：
        <ul>
          <li>综述：
            <ul>
              <li>主要有：$_GET, $_POST, $_REQUEST, $_SERVER, $GLOBALS</li>
              <li>均是数组</li>
              <li>系统定义与维护</li>
              <li>具有超全局作用域</li>
              <li>不同情形下可能具有不同的值</li>
            </ul>
          </li>
          <li>$_GET：get请求（发送数据）的4种形式
            <ul>
              <li>&lt;form   method=”get” &gt;</li>
              <li>&lt;a   href=”abc.php?a=5&amp;b=xyz”&gt;内容&lt;/a&gt; </li>
              <li>location.href=”abc.php?a=5&amp;b=xyz” ;</li>
              <li>location.assign(“abc.php?a=5&amp;b=xyz”);</li>
            </ul>
          </li>
          <li>$_POST
            <ul>
              <li>基本形式：&lt;form   method=”post” &gt;</li>
            </ul>
          </li>
          <ul>
            <li>注意特殊的表单项的写法：多选通常要使用数组形式命名 </li>
            <li>另外，post方式时在action中还可以带参数，且作为get方式 </li>
              </ul>
          <li>$_REQUEST
                <ul>
                  <li>实际是$_GET和$_POST的合集 </li>
                  <li>如果两者有重名项，默认是$_POST项覆盖$_GET项 </li>
                  <li>可以在php.ini配置文件中设定先后顺序，后者覆盖前者：request_order=GP </li>
                  <li>$_GET, $_POST, $_REQUEST三种数据是相互独立的。 </li>
                </ul>
          </li>
          <li>$_SERVER：保存了服务器或客户端的有关信息。
            <ul>
              <li>常用的有：REMOTE_ADDR, DOCUMENT_ROOT,  PHP_SELF </li>
              <li>输出所有项（可能每台服务器有所差异） </li>
            </ul>
          </li>
          <li>$GLOBALS：保存了用户定义的所有全局变量的数据 </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>常量：
    <ul>
      <li>含义： </li>
      <li>定义形式：
        <ul>
          <li>使用define()函数定义
            <ul>
              <li>推荐常用名使用全大写形式</li>
            </ul>
          </li>
          <li>使用const语法定义
            <ul>
              <li>但const语法只能在“最顶层”的代码域中使用</li>
              <li>也即，const语法不能在函数中或条件语句中或其他表示一个“范围”的语句中使用</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>使用形式：
        常量的使用就是取得其值；
        有以下2个方式：
        <ul>
          <li>1，直接使用名字：echo PI;</li>
          <li>2，或使用constant()函数：echo constant(&quot;PI&quot;);</li>
        </ul>
      </li>
      <li>常量和变量的区别
        <ul>
          <li>定义形式不同： </li>
          <li>使用形式不同：常量无需$符号 </li>
          <li>可变程度不同：常量的值不可以改变，常量也不可以销毁 </li>
          <li>作用范围不同：常量具有超全局作用域 （函数内外都可以直接使用）</li>
          <li>可用类型不同：常量只能存储标量类型 </li>
        </ul>
      </li>
      <li>判断常量是否存在：defined() </li>
      <li>一个特殊情况： 当使用未定义的常量时；</li>
      <li>预定义常量：
        <ul>
          <li>比如M_PI, PHP_OS, PHP_VERSION，PHP_INT_MAX </li>
          <li>参考手册〉附录〉保留字列表〉预定义常量 </li>
        </ul>
      </li>
      <li>魔术常量
        <ul>
          <li>比如：__DIR__，__FILE__，__LINE__ </li>
          <li>魔术常量其实类似变量，其值随着不同代码而变化；</li>
          <li>参考手册〉语言参考〉常量〉魔术常量 </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>数据类型：
    <ul>
      <li>类型总体划分：
        <ul>
          <li>标量类型： int， float， string， bool</li>
          <li>复合类型： array， object</li>
          <li>特殊类型： null， resouce</li>
        </ul>
      </li>
      <li>整数类型：int， integer
        <ul>
          <li>整数的的不同进制形式的写法：
            <ul>
              <li>十进制写法：123</li>
              <li>八进制写法： 0123</li>
              <li>十六进制写法： 0x123</li>
            </ul>
          </li>
          <li>进制转换问题
            <ul>
              <li>十进制转二进制decbin()，除2取余倒着写 </li>
              <li>十进制转八进制decoct()，除8取余倒着写 </li>
              <li>十进制转十六进制dechex()，除16取余倒着写 </li>
              <li>二进制转十进制bindec()，每位数值乘以2的权值然后相加 </li>
              <li>八进制转十进制octdec() ，每位数值乘以8的权值然后相加 </li>
              <li>十六进制转十进制hexdec() ，每位数值乘以16的权值然后相加 </li>
              <li>注意：十进制转为其他进制结果是字符串，其他进制转为十进制要求给定数据是字符串形式</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>浮点数类型：float，double
        ，real
        <ul>
          <li>浮点数的2种写法：
            <ul>
              <li>小数写法：</li>
              <li>科学计数法：</li>
            </ul>
          </li>
          <li>关于浮点数的细节知识
            <ul>
              <li>浮点数不应进行大小比较</li>
              <li>小数转二进制的做法：乘2并顺序取整数部分 </li>
              <li>当整数运算的结果超出整数的范围后，会自动转换为浮点数。</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>字符串类型：string
        <ul>
          <li>单引号字符串： </li>
          <li>双引号字符串： </li>
          <li>定界符字符串heredoc： </li>
          <li>定界符字符串nowdoc： </li>
          <li>字符串中的变量：双引号和heredoc形式中可以识别 </li>
        </ul>
      </li>
      <li>布尔类型：bool， boolean
        <ul>
          <li>被当作false的数据 ：null, &quot;&quot;, 0, 0.0, &quot;0&quot;, array(), 未定义</li>
          <li>其他的都会当作true</li>
        </ul>
      </li>
      <li>数组类型： array
        <ul>
          <li>定义： </li>
          <li>赋值： </li>
          <li>取值： </li>
          <li>下标，键，key </li>
          <li>值，value </li>
          <li>元素顺序问题 </li>
        </ul>
      </li>
      <li>对象类型： object
        <ul>
          <li>定义类： </li>
          <li>创建对象： </li>
          <li>对象属性操作：</li>
          <li>对象方法操作： </li>
        </ul>
      </li>
      <li>资源类型：resource
        <ul>
          <li>含义：基本上都是指对外部数据的引用。<br />
          不是PHP语言通过某种语法形式“创造”的数据，而是外部本来就有该数据（比如数据库，文件，图片），PHP只是通过某种语法（或方式）来对其进行某些操作。 </li>
        </ul>
      </li>
      <li>空类型：null </li>
      <li>类型转换问题：
        <ul>
          <li>自动转换：
            根据数据所使用的具体环境而可能会发生自动转换，
            常见的自动转换情形如：
            <ul>
              <li>if(数据){}：转为bool类型 </li>
              <li>算术运算符：转为数字类型 </li>
              <li>连接运算符：转为字符串类型 </li>
              <li>比较运算符：转为布尔类型或数字类型 </li>
            </ul>
          </li>
          <li>强制转换：
            <ul>
              <li>语法：(目标类型)数据 </li>
              <li>常见：(int), (float), (string),  (bool) </li>
            </ul>
          </li>
        </ul>
      </li>
      <li>类型相关的系统函数：
        <ul>
          <li>var_dump()</li>
          <li>getType(), setType();</li>
          <li>isset(), empty(), unset();</li>
          <li>is_XX类型() 系列函数：</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>运算符
    <ul>
      <li>算术运算符：
        <ul>
          <li>一般 </li>
          <li>注意取余运算%，先取整，再取余 </li>
          <li>自增自减运算符
            <ul>
              <li>常规：对数字进行自加1或自减1。 </li>
              <li>字符串： 只能自增，且自增的效果就是“下一个字符” </li>
              <li>布尔值递增递减无效 </li>
              <li>null递减无效，递增结果为1 </li>
            </ul>
          </li>
          <li>前自增和后自增的区别（自减类似）：
            <ul>
              <li>前++：先完成变量的递增运算，再取得该变量的值参与别的运算。 </li>
              <li>后++：先将原来变量的值临时存储，再将变量值递增，最后再将临时存储的值参与别的运算。 </li>
              <li>推论1：如果独立语句中进行自加运算，前自加后自加没有区别 。</li>
              <li>推论2：如果前自加后自加是放在别的语句中，则会有所区别。 </li>
              <li>推论3： 前加加比后加加效率略高（在循环中建议使用前加加）。</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>比较运算符：
        <ul>
          <li>一般比较： </li>
          <li>==和===比较 </li>
          <li>不要对浮点数直接进行大小比较 </li>
          <li>常见不同类型的比较
            <ul>
              <li>有布尔值，转为布尔值比较 </li>
              <li>有数字转为数字比较 </li>
              <li>两边都是纯数字字符串，转为数字比较 </li>
              <li>否则就按字符串比较 </li>
            </ul>
          </li>
        </ul>
      </li>
      <li>逻辑运算符：
        <ul>
          <li>基本：
            <ul>
              <li>与运算：</li>
              <li>或运算：</li>
              <li>非运算：</li>
            </ul>
          </li>
          <li>短路现象
            <ul>
              <li>逻辑与短路： </li>
              <li>逻辑或短路： </li>
            </ul>
          </li>
        </ul>
      </li>
      <li>字符串运算符： </li>
      <li>赋值运算符：
        <ul>
          <li>标准赋值 </li>
          <li>自赋值 </li>
        </ul>
      </li>
      <li>条件（三目）运算符： </li>
      <li>位运算符：
        <ul>
          <li>位运算符基本规则：
            针对0和1这2个二进制数字的基本位运算
            <ul>
              <li>&amp; ： 两个都是1，结果才是1（有一个是0，结果就是0）；</li>
              <li>| ： 两个都是0，结果才是0（有一个是1，结果就是1）；</li>
              <li>～ ： 取二进制数字的相反值，即：～1的结果是0，～0的结果是1；</li>
              <li>^：2个运算数相同，结果是0，两个运算符不同，结果是1。</li>
            </ul>
          </li>
          <li>按位与运算（&amp;)： </li>
          <li>按位或运算（|）： </li>
          <li>按位非运算（～）： </li>
          <li>按位左移运算（&lt;&lt;）： </li>
          <li>按位右移运算（&gt;&gt;）： </li>
          <li>按位异或运算（^）： </li>
          <li>补充介绍：原码，反码，补码
            <ul>
              <li>原码：一个数字的原始二进制形式，人可理解。其中最左1位为符号位，0表示正数，1表示负数。 </li>
              <li>反码：正数的反码是其本身（即不变），负数的反码：符号位不变，各位取反</li>
              <li>补码：正数的补码是其本身（即不变），负数的补码：符号位不变，各位取反后加1（即反码加1）</li>
              <li>补码还原：正数无需还原，负数：符号位不变，各位取反加1——三码转换时，符号位独立（不参与转换）</li>
              <li>计算机cpu中的运算，只有加法运算，没有减法运算</li>
              <li>用补码来表示一个数，就可以将减法转换为加法：15-13相当于15+(-13) ——实际运算时，符号位一起（参与运算）</li>
              <li>举例计算：5+3， 5-3 </li>
            </ul>
          </li>
          <li> 应用：管理一组对象（事物）的开关状态
            <ul>
              <li>有些事物（数据）只有2个状态（值），此时可以称为“开关状态”，比如灯的亮灭状态，商品是否推荐状态</li>
              <li>用二进制原理可以方便轻松管理多个该类事物的状态：</li>
              <li>每个事物的状态用一个变量值来表示：$S1=1，$S2=2，$S3=4，$S4=8，$S5=16，...</li>
              <li>则所有灯的总状态变量：$state = &quot;11111&quot;(2进制)就表示他们都是“开”的。$state = &quot;11110&quot;(2进制)就表示第1盏灯是关的，其余是开的。$state=&quot;11010&quot;(2进制）就表示第1第3盏灯是关的，其余是开的。</li>
              <li>判断某盏灯的状态（亮或灭）：如果($state &amp; $Sn)&gt;0，则表示亮，否则表示灭（其中$Sn代表某盏灯，即$S1,$S2,$S3,$S4,$S5之一，下同）。</li>
              <li>对于任意的初始状态，想要打开某盏灯：$state = $state | $Sn。</li>
              <li>对于任意的初始状态，想要关闭某盏灯：$state = $state &amp; ～$Sn。</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>数组运算符：+  ==    !=   &lt;&gt;    ===     !== 
        <ul>
          <li>联合（+）：将右边的数组项合并到左边数组的后面，得到一个新数组。如有重复键，则结果以左边的为准</li>
          <li>相等（==）： 如果两个数组具有相同的键名和键值（可以顺序不同，或类型不同），则返回true</li>
          <li>不相等（!=, &lt;&gt;） ：如果两个数组不是相等（==），则返回true</li>
          <li>全等（===）：如果两个数组具有相同的键名和键值且顺序和类型都一样，则返回true</li>
          <li>不全等（!==) ： 如果两个数组不是全等（===），则返回true</li>
        </ul>
      </li>
      <li>错误控制运算符@：用于一个表达式的前面，以抑制该表达式可能产生的报错信息。</li>
      <li>运算符的优先级问题
        <ul>
          <li>要意识到运算符有优先级问题</li>
          <li>括号最优先，赋值最落后（通常）</li>
          <li>先乘除后加减</li>
          <li>大致：单目运算符〉算术运算符〉比较运算符〉逻辑运算符（除了“非”运算）</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>流程控制：
    <ul>
      <li>流程图基本符号：开始结束，语句（块），判断，输入输出，走向 </li>
      <li>分支结构
        <ul>
          <li>if</li>
          <li>if else</li>
          <li>if else if（推荐）</li>
          <li>if elseif</li>
          <li>if else if else</li>
          <li>switch
                  <ul>
                    <li>break的作用 </li>
                    <li>不使用break的技巧</li>
                  </ul>
          </li>
        </ul>
      </li>
      <li>循环结构：
        <ul>
          <li>while</li>
          <li>do while</li>
          <li>for</li>
          <li>foreach（用于数组遍历循环） </li>
          <li>循环的中断
            <ul>
              <li>break</li>
              <li>continue</li>
              <li>中断层级 </li>
            </ul>
          </li>
        </ul>
      </li>
      <li>部分流程控制的替换语法：
        <ul>
          <li>if ( ... ) :    。。。。  endif; </li>
          <li>if ( ... ) :   。。。else: 。。。 endif; </li>
          <li>if ( ... ): 。。。elseif( ... ) : 。。。 elseif( ... ): 。。。 else: 。。。 endif; </li>
          <li>switch( ... ) : case ... case ... endSwitch;</li>
          <li>while(...): 。。。endwhile;</li>
          <li>for(...; ...; ...): :。。。 endfor;</li>
        </ul>
      </li>
      <li>
        goto语句： 
		<ul>
          <li>基本形式： goto Flag; ... Flag: .....</li>
          <li>注意事项： 
            <ul>
              <li>不能跳入循环中</li>
              <li>不能跳入函数中</li>
              <li>不能跳出函数外</li>
              <li>不能跳出文件外</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>控制脚本执行进度
        <ul>
          <li>die() / exit();</li>
          <li>sleep()</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>文件加载
    <ul>
      <li>综述和基本语法：include, require, include_once,  require_once：</li>
      <li>文件路径问题
        <ul>
          <li>相对路径： ./    ../</li>
          <li>绝对路径： c:/abc/def/ 或：http://www.abc.com</li>
          <li>无路径设定（只给出文件名，不推荐）：默认会在当前网页所在目录下找该文件</li>
        </ul>
      </li>
      <li>文件载入和执行过程：
        <ul>
          <li>从include语句处退出php脚本模式（进入html代码模式）</li>
          <li>载入include语句所设定的文件中的代码，并执行之（如同在当前文件中一样）</li>
          <li>退出html模式重新进入php脚本模式，继续之后的代码</li>
        </ul>
      </li>
      <li>include_once 和include的区别</li>
      <li>require 和 include的区别：引用失败（出错）时，include警告并继续，require终止。</li>
      <li>require 和 require_once的区别</li>
      <li>在被载入文件中 return 关键字的作用
        <ul>
          <li>默认情况下include载入成功返回1，载入失败返回false</li>
          <li>但被包含的文件中可以使用return语句返回数据值并终止该文件的后续部分的执行</li>
          <li>return返回的数据如同函数返回值一样可以进一步处理（比如赋值给其他变量）</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>错误处理：
    <ul>
      <li>错误的分类：
        <ul>
            <li>语法错误：程序没法运行，直接提示语法错误</li>
          <li>运行时错误：只有程序运行到某行，或在某些特定的情形下运行才会发生的错误。</li>
          <li>逻辑错误：程序从头到尾运行都没有发生（并提示）错误，但程序运行计算的结果是错误的。</li>
        </ul>
      </li>
      <li>错误分级与代号： 不同的错误会导致不同程度的程序运行反应，这就是错误的分级。
        错误代号其实只是一个系统内部常量。也就是说，这些错误代号是一个系统预先定义好的数据，然后系统根据发生的不同错误情形，而分配不同的值供程序员使用来判断错误类型。
        <ul>
            <li>系统错误：E_ERROR, E_WARNING, E_NOTICE</li>
          <li>用户错误：E_USER_ERROR, E_USER_WARNING, E_USER_NOTICE</li>
          <li>所有错误： E_ALL | E_STRICT</li>
          <li>PHP手册〉函数参考〉影响PHP行为的扩展〉错误处理〉预定义常量</li>
        </ul>
      </li>
      <li>错误的触发：
        <ul>
            <li>程序运行时触发。</li>
          <li>程序中通过触发函数来人为触发3种用户错误
            <ul>
                  <li>trigger_error(&quot;错误提示文字&quot;, 错误类型T）</li>
              <li>错误类型T：E_USER_ERROR, E_USER_WARNING, E_USER_NOTICE之一</li>
            </ul>
          </li>
          <li>其中，系统关键错误(E_ERROR)或用户关键错误(E_USER_ERROR)一旦发生，则程序停止执行。</li>
        </ul>
      </li>
      <li>显示错误报告：
        <ul>
            <li>display_errors = On || Off ，或 ini_set(&quot;display_errors&quot;, 0或1);</li>
          <li>error_reporting = E_ALL，或ini_set('error_reporting', E_ALL);</li>
        </ul>
      </li>
      <li>记录错误日志：
        <ul>
            <li>log_errors = On||Off， 或ini_set('log_errors', 1或0);</li>
          <li>error_log = &quot;错误日志文件名&quot;， 或ini_set('error_log', &quot;错误日志文件名&quot;);</li>
          <li>error_log = &quot;syslog&quot;则会将错误信息记录到系统日志去。</li>
        </ul>
      </li>
      <li>自定义错误处理器：
        <ul>
            <li>设定错误由我们自定义函数来处理：set_error_handler(&quot;函数名&quot;);</li>
          <li>定义该函数，带4个参数：function errorHandler($errNo, $errMsg, $errFile, $errLine){...}</li>
          <li>这样，发生错误之后，就会调用该函数来处理该错误</li>
          <li>但如果发生系统关键错误（E_ERROR），则不会去调用自定义错误处理函数，而是会直接停止运行，并按php.ini的设定显示或记录错误信息。</li>
          <li>除了系统关键错误，其他错误发生后则不会再去显示或记录错误了，而是按照自定义错误处理函数中的代码执行。</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>函数
    <ul>
      <li>基本使用
        <ul>
          <li>函数定义形式</li>
          <li>函数调用形式</li>
          <li>函数调用流程分析
            <ul>
              <li>开始调用：实际参数传数据给形式参数</li>
              <li>程序执行流程进入到函数中（一个独立的运行空间），跟全局执行空间是隔离的</li>
              <li>按常规的程序逻辑执行函数中的代码</li>
              <li>如果碰到return语句，则终止函数的执行，跳回函数开始调用的位置；</li>
              <li>如果执行到函数的最后位置，也同样跳回函数开始调用的位置</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>函数参数
        <ul>
          <li>形式参数，形参，parameter</li>
          <li>实际参数，实参，arguement</li>
          <li>参数的默认值
            <ul>
                <li>形式：形式参数上给其赋值（就是默认值）</li>
              <li>要求：
                <ul>
                      <li>默认值不能是对象或资源类型；</li>
                  <li>默认值只能是常量表达式，或常量，不能是变量</li>
                  <li>默认值参数必须放在非默认值参数的右边</li>
                </ul>
              </li>
            </ul>
          </li>
          <li>参数传值问题
            <ul>
              <li>默认情况下，参数传值采用的是“值传递”的方式进行传值。</li>
              <li>可以在形式参数的前面使用“＆”符号，来达到“引用传递”的传值方式。</li>
              <li>注意1：如果是引用传值，则实参只能是一个“变量”——也即变量跟变量之间才有引用传值方式问题。</li>
              <li>注意2：引用传值的形参变量，在函数内部改变该形参变量的值，则对应实参变量的值也就改变。</li>
            </ul>
          </li>
          <li>参数的数量问题
            <ul>
              <li>常规：实际参数数量跟形式参数一致；</li>
              <li>实际参数数量多于形式参数，不报错（很多其他语言是报错的）；</li>
              <li>实际参数数量少于形式参数，则分为：
                <ul>
                  <li>实际参数数量少于形式参数的非默认参数数量，则报错</li>
                  <li>实际参数数量不少于形式参数的非默认参数数量，则不报错，不够部分，使用默认参数值</li>
                </ul>
              </li>
              <li>不定参数数量的情形：
                <ul>
                  <li>类似：var_dump()可以传递不定个数的参数，如何做实现？</li>
                  <li>定义的时候不定义形式参数</li>
                  <li>在函数内部，使用func_get_args()获取所有传递过来的实际参数值，结果是一个数组</li>
                  <li>在函数内部，使用func_get_arg(n)获得第n个参数（n从0开始）</li>
                  <li>在函数内部，使用func_num_args()获得所有实际参数的个数</li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>
      </li>
      <li>函数的返回值
        <ul>
          <li>一个函数，可以返回数据值，也可以不返回。需不需要返回数据值，由应用所需来决定。</li>
          <li>如果需要返回值，则使用return语句后面跟一个数据（直接数据或变量数据或常量数据），就可以返回该数据（值）。</li>
          <li>如果不需要返回值，则函数中可以没有return语句，或有return语句但没有其后没有跟一个数据。</li>
          <li>return语句的作用，不管后面跟不跟数据值，都会立即终止函数的执行，返回到函数调用的位置并继续后续工作。</li>
        </ul>
      </li>
      <li>函数的其他形式
        <ul>
            <li>可变函数：一个变量名后面带括号，则会被识别为可变函数：找到与该变量的值同名的函数并执行之。</li>
          <li>匿名函数：没有名字的一个函数，可将其赋值给一个变量，然后该变量后面加括号就可以调用该函数
            <ul>
              <li>$f1 = function($p1, $p2) { ........ }</li>
              <li>call_user_func_array($f1, array(1, 2)); </li>
            </ul>
          </li>
          <li>或纯粹是一个没有名字的函数，且直接当作其他函数的参数（即该函数的参数是一个函数）。
			  <ul>
				<li>call_user_func_array( <strong>function($p1, $p2) { ........ }</strong> , array(1, 2) ); array_walk(数组,$f1)</li>
				<li>这种当作其他函数参数的函数，通常称为“callable”（可调函数），或“callback”（回调函数）。</li>
			  </ul>
		  </li>
        </ul>
      </li>
      <li>变量作用域
        <ul>
          <li>局部作用域（局部变量）
            <ul>
              <li>静态局部变量：静态变量只能赋值为一个直接的标量值，不能是计算值，或另一个变量值。</li>
            </ul>
          </li>
          <li>全局作用域（全局变量）</li>
          <li>超全局作用域（超全局变量）</li>
          <li>局部访问全局变量
            <ul>
              <li>使用$GLOBALS超全局数组</li>
              <li>使用global关键字：本质是设定一个局部变量来引用某个全局变量，删掉该局部变量，全局变量仍然存在</li>
              <li>$GLOBALS数组中的元素跟全局变量是一一对应关系。删掉（unset）一个，另一个也就没有了</li>
              <li>使用$GLOBALS数组的一个新元素，则可以“创造”全局变量，如：$GLOBALS['v1'] = 1; #假设之前没有$v1这个全局变量，则这一行之后就有了</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>有关函数的系统函数
        <ul>
          <li>function_exists()</li>
          <li>func_get_arg()</li>
          <li>func_get_args()</li>
          <li>func_num_args()</li>
        </ul>
      </li>
      <li>函数相关编程思想
        <ul>
          <li>递归思想：</li>
          <li>递推（迭代）思想：</li>
        </ul>
      </li>
      <li>常用内部函数：
        <ul>
          <li>字符串函数：
            <ul>
              <li>输出与格式化：echo , print, printf, print_r, var_dump.</li>
              <li>字符串去除与填充：trim, ltrim, rtrim, str_pad</li>
              <li>字符串连接与分割：implode, join， explode, str_split</li>
              <li>字符串截取：substr, strchr, strrchr, </li>
              <li>字符串替换：str_replace, substr_replace</li>
              <li>字符串长度与位置： strlen, strpos, strrpos, </li>
              <li>字符转换：strtolower, strtoupper, lcfirst, ucfirst, ucwords</li>
              <li>特殊字符处理：nl2br, addslashes, htmlspecialchars, htmlspecialchars_decode,</li>
            </ul>
          </li>
          <li>时间函数：
            <ul>
              <li>time, microtime, mktime, date, idate, strtotime, date_add, date_diff, date_default_timezone_set, date_default_timezone_get</li>
            </ul>
          </li>
          <li>数学函数：
            <ul>
              <li>max, min, round, ceil, floor, abs, sqrt, pow, round, rand</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>数组
    <ul>
      <li>数组基础
        <ul>
          <li>定义</li>
          <li>取值</li>
          <li>赋值</li>
        </ul>
      </li>
      <li>数组分类
        <ul>
          <li>从键值关系来分
            <ul>
              <li>关联数组</li>
              <li>索引数组</li>
              <li>混合数组</li>
            </ul>
          </li>
          <li>从数组层次来分
            <ul>
              <li>一维数组</li>
              <li>多维数组</li>
              <li>混合数组</li>
              <li>“维”的本质</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>数组遍历
        <ul>
          <li>foreach基本语法</li>
          <li>数组指针操作与遍历原理</li>
          <li>foreach遍历流程图</li>
          <li>for+next遍历数组</li>
          <li>while+each()+list()遍历数组</li>
          <li>foreach遍历的细节探讨：
            <ul>
              <li>foreach也是正常的循环语法结构，可以有break和continue等操作。</li>
              <li>遍历过程中值变量默认的传值方式是值传递。</li>
              <li>遍历过程中值变量可以人为设定为引用传递：foreach($arr as $key =&gt; &amp;$value){ ... }</li>
              <li>foreach默认是原数组上进行遍历。但如果在遍历过程中对数组进行了某种修改或某种指针性操作，则会复制数组后在复制的数组上继续遍历循环。</li>
              <li>foreach中如果值变量是引用传递，则无论如何都是在原数组上进行。</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>数组函数
        <ul>
          <li>指针操作函数： current, key, next, prev, reset, end, each</li>
          <li>单元操作函数： array_pop，array_push, array_shift, array_unshift, array_slice, array_splice</li>
          <li>排序函数： sort， asort， ksort， usort, rsort, arsort , krsort , shuffle, </li>
          <li>查找函数： in_array, array_key_exists, array_search</li>
          <li>其他函数： count, array_reverse, array_merge, array_sum, array_keys, array_values,array_map, array_walk, range</li>
        </ul>
      </li>
      <li>数组排序算法
        <ul>
          <li>冒泡排序</li>
          <li>选择排序</li>
          <li>插入排序</li>
          <li>快速排序</li>
        </ul>
      </li>
      <li>数组查找算法
        <ul>
          <li>顺序查找</li>
          <li>二分查</li>
        </ul>
      </li>
    </ul>
  </li>
  <li></li>
</ul>
</body>
</html>
