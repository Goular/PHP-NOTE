#第十三天笔记
######面向对象（由于在Java中已经学过了面向对象的思想，所以就不详细讲了）

#变量指向对象的模型

###变量:$o1----->对象编号#2(该编号可以从vardump中看到)-------->堆中的相关对象

###创建对象的几种形式
<pre>
方式一:$o1 = new 类名();////通过一个类，去new出一个对象
方式二:$o2 = new 对象的变量名(); 即，$o2 = new $o1(); ////通过一个对象，去new出一个对象——其实是new出来的是旧对象所述类的一个新对象。
方式三:$s1 = 'C1';$o3 = new $s1();//利用类的名字创建对象，这就是所谓的“可变类”——无非就是类的名字是一个变量而已。
方式四:$o4 = new self();//self表示“当前类本身”，它只能出现在一个类的方法中。

注意一点,就是形式四的使用，必须创建对象在类中，self才会有效.
</pre>

###对象的传值方式(重点中的重点，看不懂，就看笔记)
<pre>
值传递:
	$o1 = new C1();
	$o2 = $o1;//这就是使用了值传递

引用传递:
	$o1 = new C1();
	$o2 = &$o1;//这就是使用了引用传递		

为什么对于对象，值传递和引用传递，这个情况下，他们似乎没有区别？？？
实际上，变量$o1中，存储的数据只是一个“对象编号#1”，这个对象编号，才会去指向对象数据new  C1();  该编号数据，我们不能控制，只是系统内部的分配。则$o2  =  $o1；	作为值传递，实际复制的是该对象的编号.

在语法上，对对象变量进行的属性进行操作，其实就是通过该编号来指向对象而操作的。

而引用传递，指向的是是同一个存储对象编号的内容的位置，所以原本那个与引用传递的对象指向的对象编号的存储空间是同一个空间，而值传递是复制一个对象编号的存储空间给新赋值的对象，这样虽然是指向同一个对象，但是对象编号的存储空间，二者是不一样的.

</pre>

###类中成员

<pre>
类中的成员分三类:
1.属性（普通属性，静态属性）
2.方法 (普通方法，静态方法，构造方法，析构方法)
3.常量 
</pre>

###类常量
<pre>
定义:
类中添加使用的形式:const 常量名 = 常量值;//注意，不能使用defind()方法进行定义常量
使用:
类名::常量名  //"::"为范围解析符
</pre>

###普通常量
<pre>
定义:
类中添加使用的形式:var/public $变量名 = 变量值;//注意，类中的属性定义可以不赋值
使用:
$对象名->属性名 = ...;
</pre>

###静态属性
<pre>
一个类的静态属性就是一个类只有一个备份在静态区，数据只有一份，而且内容不随对象的变化而变化

定义:
static $属性名=初始值; (初始值可以省略) 

使用:
类名::$属性名; //不要忘了调用的$,不然就变成类的常量了

</pre>

###普通方法
<pre>
一个类中定义的方法，可以为这个类的所有对象调用的方法。也可以理解为，这个类的所有对象，都各自有自己的一个该方法；

定义:
class  类名{
function  方法名(形参1，形参2，.... ){
//方法体。。。
}
}

使用:
$对象名->方法名(实参1，实参2，....）；

</pre>

###静态方法
<pre>
一个类中定义的方法，只隶属于这个类本身，而不是隶属于这个类的对象。

定义:
class  类名{
static  function  方法名(形参1，形参2，.... ){
//方法体。。。
}
}

使用:
类名::静态方法名(参数1，参数2...);

</pre>

###构造方法(与java不同，一个类只能拥有一个的构造方法)
<pre>
构造方法，是一个特殊的方法：
1，名字是固定的：_ _construct；
2，该方法通常都不要我们自己调用，而是在new一个对象的时候会自动调用。
3，该方法主要的目的是为了在new一个对象的时候，给该对象设置一些“初始值”（初始化工作）；
4，构造方法的参数没有规定，通常是根据实际的需要来定义，目的是为了对象属性数据的初始化；
</pre>

###析构方法(除了执行完所有文件代码后，销毁的时候会调用对象的析构方法，但是使用unset()方法，也能提交执行析构方法，因为只要引用对象的数量小于1，那么多余的内容对象就会被回收，从而执行析构方法)
<pre>
1，析构方法是一个特殊的方法，名字为固定的词：_ _desctruct
2，析构方法是在一个对象被“销毁”的时候会自动被调用的方法——我们无法调用它；
3，析构方法不能带参数（形参），但方法中也可以使用$this这个词，代表“当前对象”；
</pre>

###(重点)对象在哪些情况下会被销毁？
<pre>
1，如果程序结束，所有变量都会被销毁，自然，变量所代表的对象也会被销毁,对象销毁的顺序，默认情况下，跟其创建的顺序相反；(因为这是由于所指向的对象编号的变量是使用栈的形式进行内存保存的，而对象的保存是使用堆来进行，栈的特性是先进后出);

2.当一个对象没有任何变量“指向”它的时候，即使程序还没有结束，也会被销毁(使用unset方法可以是变量的指向消失，从而使对象指向个数为0，才能被收回执行析构方法)；


注意值传递和引用传递在执行unset方法是销毁的过程的问题，这个是重点，这个的效果图请看笔记

总的一句，值传递保存的是对象编号，通过对象编号内容再指向对象的模型，值传递的赋值是通过复制对象编号的内容到新的存储空间，让新的变量指向该对象编号的新空间进而指向对象，所以值传递成功后，是存在两份相同的对象编号，但注意，存在堆中的对象还是只有一个，unset原来的对象编号的连接，堆中的对象不会被回收，因为此时的对象引用计数还是1，原来复制后是2，执行了unset后变为1，所以不会被回收，不会执行析构方法。

而引用传递，执行的是让新的变量指向的对象编号控件与原来的变量指向的对象编号空间是一样的，所以当该对象编号空间的内容发生改变，即原来的对象编号空间内容变为整数44或者是unset掉变量时，就会让堆中的对象计数器-1，变为0，变为0后就会自动执行析构方法销毁对象，所以引用传递执行的对象编号变更会使对象销毁，而值传递的话就算unset一个变量，只要存在计数，就不会被销毁，除非所有执行程序结束


</pre>


