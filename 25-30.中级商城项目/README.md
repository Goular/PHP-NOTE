#中级项目实战

###编程思想
<pre>
思想是很重要的。
思想的力量是很强大的。
介绍两种一思想：Oop和mvc
</pre>

###OOP思想
<pre>
OOP：Object Oriented Programming，面向对象编程，面向对象程序设计。
核心思想：使用人类思考问题、解决问题的方式来编写程序。
三大特征：
封装，通常有两层含义，第一层，将属性和方法封装到一起（通过class），形成一个完整的对象。第二层，对外隐藏具体的实现细节，提供一个可调用的接口（访问权限修饰符）。
继承，子类继承了父类的属性和方法（非私有的），使用继承可以实现代码的重用
多态，在不同的上下文中表现出不同的形态。在php中，多态并不明显，因为php本身就是多态的语言，原因在于它是弱类型的。
</pre>

###OOP好处
<pre>
可维护
可扩展
可重用
灵活度高
</pre>

###mvc模式[思想]
<pre>
解释：
MVC是一种编程思想，M，model，表示模型，完成具体的业务逻辑，V，view，表示视图，用来展示页面，C，controller，控制器，专门用来负责调度的，扮演了交通警察的角色。

描述一下：
描述整个的流程，画图说明

单一入口，index.php?p=admin&c=goods&a=insert，在后台添加商品操作。

广义上的模型，包括数据库模型和工具类模型。
狭义上的模型，就是指数据库模型，操作数据库的，以xxxModel.class.php来体现的

在项目中，肯定不止一个控制器，也不止一个模型。
既然有多个控制器和模型，需要重用代码，需要定义基础控制器和基础模型。

是整个项目的指导思想，非常重要。
优缺点：
优点，分层明确，便于维护和分工协作，便于交流。
缺点，理解比较费劲，学习成本高，对于小项目，反而感觉有些麻烦。
</pre>

#搭建过程
###编码规范说明
<pre>
命名规范

a.一定要有注释
	注释占整个项目50%

b.一定要有统一的命名规范
	所有的命名都应该尽量简洁，见名知意。


文件名
	类文件，是类名.class.php  如，GoodsController.class.php

	普通文件，文件名.php

类名，使用大驼峰命名法则，首字母大写，每个单词的首字母大写，GoodsController

方法名，使用小驼峰命名法则，首字母小写，后续的每个单词的首字母大写，如addAction

属性名，使用小驼峰 或者 下划线方式，二者选其一，保持一致即可。


函数名，遵循php本身的规则即可
	下划线式：var_dump，is_array
	直接连写式：imagecreatetruecolor
	二者选其一，保持一致即可。

常量名，保持大写

在我们的项目中，所有的控制器都是以xxxController命名的。所有的数据库模型都是以xxxModel命名的。

c. 严格区分大小写
	Windows下有时候不区分大小写，但是php做的项目通常是放在linux操作系统下，它是严格区分大小写，所以需要养成好的习惯

d. 注意缩进，代码对齐



实例化对象调用方法，获取p/c/a参数。
肯定要包含类定义文件，如何包含呢，自动加载
有这么多的文件，分别存放在不同的目录中，如何处理比较好？

初始化：定义路径常量
路由分发：实例化对象并调用方法
自动加载：实现类的自动加载

B.定义初始化方法
getcwd():获取当前工作目录 current work directory


DIRECTORY_SEPARATOR常量，路径分隔符，在不同的操作系统下解析为不同的符号，
Linux，/
Windows，\


</pre>


###实现自动加载
<pre>
说到自动加载，一定会想起__autoload。

请问，__autoload怎么用？
是函数还是方法？
函数，通常是指的普通的函数。通过function来定义的。is_array
方法，通常是指在类中定义的函数，和类挂钩的。

应该是函数。


即使在类中定义的方法名字为__autoload，它也不能起到自动加载的作用。

如何实现自动加载呢？
解决方案有两种：
	将__autoload()函数写到类的外面，以函数的形式出现，比如index.php中。

	在类中实现，首先写一个方法，实现自动加载功能，然后再将其注册为自动加载。使用spl_autoload_register函数。
我们采用第二种方案

spl_autoload_register

有一个问题，就是这个函数，只有一个参数。
但是，我们现在是在类中注册方法。需要知道是哪个类的哪一个方法。意味着我们需要传递两个参数。


如果需要通过一个参数，来传递多个指，可以使用数组。

由于callable可以使用数字或者字符串代表一个指定类的方法，所以可以写成

$arr = array(‘php’,100,true);

$arr = array(__CLASS__,'load')与'self::load'的意义相同,目的都是作为spl_auto_load的callable参数的方法

其中 __CLASS__，是魔术常量，表示当前类名。

最后在run方法中分别调用上述三个方法
</pre>


###定义控制器进行测试
<pre>
定义后台首页控制器
</pre>

###加载视图(我们不要把后台的js/css放到public中，因为那是对前台有访问权限，但是后台我们是不允许访问的，所以后台的资源不放到public文件夹)

###注意一点，就是html不能直接调取本地的内容，所以使用全路径读取内容是不行的
<pre>
加载视图，非常简单。只需要include即可
[需求]：显示后台的首页。

将后台首页对应的模板拷贝到views/admin目录下。

然后，编写方法

修改模板页面中的静态资源引用路径

如果使用了php中定义的常量输出

(重点内容)
出于安全的考虑，浏览器是不能访问本地资源的。

我们不能使用PHP常量路径输出，只能是使用网站的路径（相对路径或者写/）

注意：我们后台的静态资源直接存放到admin之下。
出于安全和效率的考虑。
</pre>


###定义核心的控制器
<pre>
在我们的项目中，有多个控制器，当中有很多相同的功能。如何实现代码重用呢？

使用继承，需要定义一个基础控制器
在哪儿定义?
有哪些功能？

这个控制器是前后台都会继承的，在其他的项目中也是可以使用的。
意味着这个基础控制器和具体的业务逻辑是没有关系的，应该放到framework中。放到core当中。所以有时候也称之为核心控制器

有哪些功能？
先实现一个功能，实现操作之后跳转，并且显示提示信息。

实现跳转的方法有如下几种：
Php中的header函数
Js中的location对象
Html中的meta头

拷贝message.html文件，发现有如下代码：
</pre>

###载入数据库模型
<pre>
对于模型，要分成两条线
数据库模型
工具类模型

首先看数据库模型

肯定离不开db对象，就是mysql类。

将mysql.class.php拷贝到framework/databases目录下，

重点方法：
getOne：获取第一条记录的第一个字段的值，返回单个值
getRow：获取单条记录，返回一位数组
getAll：获取所有的记录，返回二维数组

模型，在我们的项目中，有多个模型，都需要完成增删改查操作。
其中增删改比较特殊，他们的sql语句几乎是一样的，可以将其定义成自动完成。
将其定义到基础模型中。

将定义好的基础模型拷贝到core目录中，如下：

重点关注以下方法:
Insert：自动插入
Update：自动更新
Delete：自动删除
selectByPk：根据主键获取单条记录
Total：获取总的记录数
__construct：构造方法


模型是具体的完成CRUD操作。一定会对应一张表。
要使用模型，需要先定义一个模型，继承自基础模型，

</pre>


###count(*)和count(字段名)
<pre>

对于count(*)而言，只要有记录，就被纳入统计
对于count(字段)，如果该字段的值为null，则不会纳入统计。


不要使用*，可以
提高查询效率，节省资源
避免出现逻辑错误

</pre>

###inner join 和 left join
<pre>
关于inner join 和left join的选择，我是选inner join 还是left join 呢？
凡是能够使用inner join的地方，完全可以使用left join。

能够使用left join的地方，不一定能使用inner join。
结论：所有的地方都可以使用left join。
</pre>