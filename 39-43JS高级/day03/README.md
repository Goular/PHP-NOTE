#JavaScript高级第三天

###前一天作业
<pre>
1.利用dom技术实现无序列表(ul/li)制作,至少4个li的项目，最后在body里边显示出来
2.在1作业的基础上，给每个li设置mouseover和mouseout事件，控制li的背景颜色(设置/取消)，达到鼠标当前行高亮显示的效果
</pre>

#变量作用域链
###定义
<pre>
变量在当前环境now、内部环境f1、内部深层环境f2/f3....都起作用的现象形成了一个链条,这个链条就称为变量的"作用域链"
</pre>


###变量的作用域是声明时决定的，而不是运行时
###作用域链的作用
<pre>
2.1 变量必须“先声明、后使用”
	函数可以“先使用、后声明”，原因是函数有“预加载”过程
2.2 内部环境可以访问外部环境的变量，反之不然
	环境：每个函数内部都是一个环境，最外边是全局环境。

2.3 变量的作用域是声明时决定的，而不是运行时

两种类型：函数环境、全局环境
</pre>

###AO活动对象
<pre>
AO: Active Object 活动对象(抽象的)
执行环境：
js代码执行是有环境的(全局环境、函数内部环境)
环境定义了其有权访问的其他数据
环境有一个与之关联的“活动对象AO”
环境中所有的变量和函数都是活动对象AO的成员
全局环境是最外围的执行环境，活动对象是window对象
执行环境中的代码执行完毕后就被销毁

每个环境都通过AO定义了其权访问的一些数据
</pre>

###变量的类型及访问优先顺序
<pre>
四种类型：内部变量>>>内部函数>>>形参>>>外部变量(变量/函数/形参)

4种类型变量及访问优先级

</pre>

#重新认识全局变量和局部变量
###全局变量
<pre>
声明：
① 在函数外部声明的变量
② 在函数内部不使用var声明的变量(前提是函数执行之后才起作用)

重新认识：
全局变量 是活动对象window的成员信息。
在访问的时候，window是否设置都可以，如果设置window可以提高代码可读性
</pre>

###局部变量
<pre>
声明：
在函数内部通过var声明的变量就是局部变量。

重新认识：
局部变量 相对概念上，在一定范围内可以看做是“全局变量”。
其在 本环境、内部环境、内部深层环境 都可以被访问。
</pre>

#闭包
###什么是闭包
<pre>
闭包就是一个函数，两个函数彼此嵌套，内部函数就是闭包
形成闭包条件是内部函数需要通过return给返回出来.
</pre>

###闭包特点
<pre>
闭包有权利调用其上级环境的变量信息。父级环境的信息已经固化为本身AO的成员了。

闭包特点及原理
</pre>

###闭包使用规则
<pre>
同一个闭包机制可以创建多个闭包函数出来，它们彼此没有联系，都是独立的。
并且每个闭包函数可以保存自己个性化的信息。

三个闭包彼此独立、没有联系
</pre>

###闭包总结
<pre>
1.变量的作用域链
2.作用域链的作用
a)变量必须“先声明、后使用”
b)内部环境可以访问外部环境变量，反之不然
c)变量的作用域是声明时决定的，非运行时
3.AO活动对象
js代码执行的时候，环境变量的获取是“固态”过程，一个环境可以访问的变量信息早早地已经固化为本身环境AO的成员。
环境类型：全局环境、函数环境
   全局环境AO活动对象就是window
4.变量类型及优先级关系
类型： 内部变量>>>内部函数>>>形参>>>外部变量
5.全局变量和局部变量重新认识
6.闭包
</pre>

#面向对象
<pre>
PHP里边，是从一个类里边获得一个具体对象。
Javascript里边，没有类的概念，可以直接创建一个对象(或通过函数)出来，对象可以有默认成员，后期也可以给对象丰富成员出来。
</pre>

###创建对象
<pre>
① 字面量方式创建
var obj = {成员名称:值,名称:值,名称:值...};
② 构造函数创建对象
var obj = new 函数名称();
③ Object方式创建对象
var obj = new Object();

字面量方式创建对象   及对象访问成员和丰富成员

构造函数方式创建对象

Object方式创建对象
</pre>

###对象在内存分配
<pre>
与对象有关系的内存空间：
①. 栈空间
存放的数据大小比较小，一般大小固定的信息适合存放在该空间，例如 整型、boolean、对象的名称(引用)。
var dog = new Animal();  //对象体
②. 堆空间
该空间存储的数据比较多，空间较大，一般数据长度不固定的信息在该空间存放，例如： string、Array、对象实体
var dog = new Animal();

③. 数据空间
该空间存放常量、类的静态属性
④. 代码空间
存放函数体代码、方法体代码

对象在内存的分配
</pre>

###对象调用 其他函数 或 其他对象成员
<pre>
对象调用其他函数
对象调用其他对象方法
</pre>

###构造函数 与 普通函数
<pre>
构造函数和普通函数的区别：
没有区别，就看使用，new就是构造函数，函数()就是普通函数调用。
</pre>

###函数的各种执行方式
<pre>
① 普通函数调用(包括匿名函数自调用)
② 构造函数执行 new  函数
③ 作为对象的成员方法执行
④ 通过call或apply执行
	函数/方法.call(函数内部this指引，实参，实参，实参。。。)
	函数/方法.apply(函数内部this指引，[实参，实参，实参。。。])
	call和apply使得函数执行的时候可以控制变量污染的风险。
	(对象调用其他函数/方法的时候，无需为对象创建新成员)

call使得函数执行

call使得对象在不创建新成员情况下，可以调用其他函数

call方式 实现  对象调用其他对象成员方法
</pre>

###this都是谁
<pre>
① 在 函数/方法 里边 this代表调用该函数/方法的当前对象。
② 在事件中，this代表元素节点对象.
inputnode.onclick = function(){
alert(this.value);
}
③ 代表window。
④ 可以任意代表其他对象
在call和apply使用的时候，可以任意设置被执行函数内部this的代表
</pre>

###获取构造器
<pre>
构造器：使用什么元素实例化的对象，元素就称为该对象的构造器
(php类/javascript函数)
var cat = new Animal();
Animal就称为cat对象的构造器。

对象.constructor;  //获得构造器


通过new  Function()方式创建一个函数出来
</pre>

###return对实例化对象的影响
<pre>
机会没有影响，影响的部分都是return后的区域的内容无法执行
</pre>

###总结
<pre>
1.闭包案例使用(数组元素创建、事件操作)
闭包使用规则：同一个闭包机制创建出来的多个闭包函数，彼此独立，并且每个函数内部有自己可以访问的个性化(差异)信息
2.面向对象
a)对象创建(字面量方式、构造函数方式、Object方式)
b)对象在内存中分配(栈、堆、代码、数据)
c)对象调用其他函数或方法
为对象增加一个成员，该成员就是被调用函数/方法的另一个名字

d)普通函数 和 构造函数区别

e)call和apply方式使得函数/方法执行
函数/方法.call(函数内部this引用，实参，实参，实参)
好处：减少新名字出现，降低变量污染的风险

f)this关键字代表意思(window、元素节点对象、函数内部代表调用的当前对象、任意代表其他对象)
g)构造器获取  对象.constructor
h)return的影响
</pre>
